<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决hibernate自动生产的表字段顺序与实体类顺序不一致的问题]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[重写hibernate的PropertyContainer,使创建的表的顺序与实体类顺序一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300package org.hibernate.cfg;import org.hibernate.AnnotationException;import org.hibernate.MappingException;import org.hibernate.annotations.ManyToAny;import org.hibernate.annotations.Target;import org.hibernate.annotations.Type;import org.hibernate.annotations.common.reflection.XClass;import org.hibernate.annotations.common.reflection.XProperty;import org.hibernate.boot.jaxb.Origin;import org.hibernate.boot.jaxb.SourceType;import org.hibernate.cfg.annotations.HCANNHelper;import org.hibernate.internal.CoreMessageLogger;import org.hibernate.internal.util.StringHelper;import org.jboss.logging.Logger;import javax.persistence.*;import java.util.*;/** * 重写hibernate的PropertyContainer,使创建的表的顺序与实体类顺序一致 * * */class PropertyContainer &#123; private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PropertyContainer.class.getName()); /** * The class for which this container is created. */ private final XClass xClass; private final XClass entityAtStake; /** * Holds the AccessType indicated for use at the class/container-level for cases where persistent attribute * did not specify. */ private final AccessType classLevelAccessType; private final LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap; PropertyContainer(XClass clazz, XClass entityAtStake, AccessType defaultClassLevelAccessType) &#123; this.xClass = clazz; this.entityAtStake = entityAtStake; if ( defaultClassLevelAccessType == AccessType.DEFAULT ) &#123; // this is effectively what the old code did when AccessType.DEFAULT was passed in // to getProperties(AccessType) from AnnotationBinder and InheritanceState defaultClassLevelAccessType = AccessType.PROPERTY; &#125; AccessType localClassLevelAccessType = determineLocalClassDefinedAccessStrategy(); assert localClassLevelAccessType != null; this.classLevelAccessType = localClassLevelAccessType != AccessType.DEFAULT ? localClassLevelAccessType : defaultClassLevelAccessType; assert classLevelAccessType == AccessType.FIELD || classLevelAccessType == AccessType.PROPERTY; this.persistentAttributeMap = new LinkedHashMap&lt;String, XProperty&gt;(); final List&lt;XProperty&gt; fields = xClass.getDeclaredProperties( AccessType.FIELD.getType() ); final List&lt;XProperty&gt; getters = xClass.getDeclaredProperties( AccessType.PROPERTY.getType() ); preFilter( fields, getters ); final Map&lt;String,XProperty&gt; persistentAttributesFromGetters = new HashMap&lt;String, XProperty&gt;(); collectPersistentAttributesUsingLocalAccessType( persistentAttributeMap, persistentAttributesFromGetters, fields, getters ); collectPersistentAttributesUsingClassLevelAccessType( persistentAttributeMap, persistentAttributesFromGetters, fields, getters ); &#125; private void preFilter(List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; Iterator&lt;XProperty&gt; propertyIterator = fields.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty property = propertyIterator.next(); if ( mustBeSkipped( property ) ) &#123; propertyIterator.remove(); &#125; &#125; propertyIterator = getters.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty property = propertyIterator.next(); if ( mustBeSkipped( property ) ) &#123; propertyIterator.remove(); &#125; &#125; &#125; private void collectPersistentAttributesUsingLocalAccessType( LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap, Map&lt;String,XProperty&gt; persistentAttributesFromGetters, List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; // Check fields... Iterator&lt;XProperty&gt; propertyIterator = fields.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty xProperty = propertyIterator.next(); final Access localAccessAnnotation = xProperty.getAnnotation( Access.class ); if ( localAccessAnnotation == null || localAccessAnnotation.value() != javax.persistence.AccessType.FIELD ) &#123; continue; &#125; propertyIterator.remove(); persistentAttributeMap.put( xProperty.getName(), xProperty ); &#125; // Check getters... propertyIterator = getters.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty xProperty = propertyIterator.next(); final Access localAccessAnnotation = xProperty.getAnnotation( Access.class ); if ( localAccessAnnotation == null || localAccessAnnotation.value() != javax.persistence.AccessType.PROPERTY ) &#123; continue; &#125; propertyIterator.remove(); final String name = xProperty.getName(); // HHH-10242 detect registration of the same property getter twice - eg boolean isId() + UUID getId() final XProperty previous = persistentAttributesFromGetters.get( name ); if ( previous != null ) &#123; throw new org.hibernate.boot.MappingException( LOG.ambiguousPropertyMethods( xClass.getName(), HCANNHelper.annotatedElementSignature( previous ), HCANNHelper.annotatedElementSignature( xProperty ) ), new Origin( SourceType.ANNOTATION, xClass.getName() ) ); &#125; persistentAttributeMap.put( name, xProperty ); persistentAttributesFromGetters.put( name, xProperty ); &#125; &#125; private void collectPersistentAttributesUsingClassLevelAccessType( LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap, Map&lt;String,XProperty&gt; persistentAttributesFromGetters, List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; if ( classLevelAccessType == AccessType.FIELD ) &#123; for ( XProperty field : fields ) &#123; if ( persistentAttributeMap.containsKey( field.getName() ) ) &#123; continue; &#125; persistentAttributeMap.put( field.getName(), field ); &#125; &#125; else &#123; for ( XProperty getter : getters ) &#123; final String name = getter.getName(); // HHH-10242 detect registration of the same property getter twice - eg boolean isId() + UUID getId() final XProperty previous = persistentAttributesFromGetters.get( name ); if ( previous != null ) &#123; throw new org.hibernate.boot.MappingException( LOG.ambiguousPropertyMethods( xClass.getName(), HCANNHelper.annotatedElementSignature( previous ), HCANNHelper.annotatedElementSignature( getter ) ), new Origin( SourceType.ANNOTATION, xClass.getName() ) ); &#125; if ( persistentAttributeMap.containsKey( name ) ) &#123; continue; &#125; persistentAttributeMap.put( getter.getName(), getter ); persistentAttributesFromGetters.put( name, getter ); &#125; &#125; &#125; public XClass getEntityAtStake() &#123; return entityAtStake; &#125; public XClass getDeclaringClass() &#123; return xClass; &#125; public AccessType getClassLevelAccessType() &#123; return classLevelAccessType; &#125; public Collection&lt;XProperty&gt; getProperties() &#123; assertTypesAreResolvable(); return Collections.unmodifiableCollection( persistentAttributeMap.values() ); &#125; private void assertTypesAreResolvable() &#123; for ( XProperty xProperty : persistentAttributeMap.values() ) &#123; if ( !xProperty.isTypeResolved() &amp;&amp; !discoverTypeWithoutReflection( xProperty ) ) &#123; String msg = "Property " + StringHelper.qualify( xClass.getName(), xProperty.getName() ) + " has an unbound type and no explicit target entity. Resolve this Generic usage issue" + " or set an explicit target attribute (eg @OneToMany(target=) or use an explicit @Type"; throw new AnnotationException( msg ); &#125; &#125; &#125; private AccessType determineLocalClassDefinedAccessStrategy() &#123; AccessType classDefinedAccessType; AccessType hibernateDefinedAccessType = AccessType.DEFAULT; AccessType jpaDefinedAccessType = AccessType.DEFAULT; org.hibernate.annotations.AccessType accessType = xClass.getAnnotation( org.hibernate.annotations.AccessType.class ); if ( accessType != null ) &#123; hibernateDefinedAccessType = AccessType.getAccessStrategy( accessType.value() ); &#125; Access access = xClass.getAnnotation( Access.class ); if ( access != null ) &#123; jpaDefinedAccessType = AccessType.getAccessStrategy( access.value() ); &#125; if ( hibernateDefinedAccessType != AccessType.DEFAULT &amp;&amp; jpaDefinedAccessType != AccessType.DEFAULT &amp;&amp; hibernateDefinedAccessType != jpaDefinedAccessType ) &#123; throw new MappingException( "@AccessType and @Access specified with contradicting values. Use of @Access only is recommended. " ); &#125; if ( hibernateDefinedAccessType != AccessType.DEFAULT ) &#123; classDefinedAccessType = hibernateDefinedAccessType; &#125; else &#123; classDefinedAccessType = jpaDefinedAccessType; &#125; return classDefinedAccessType; &#125; private static boolean discoverTypeWithoutReflection(XProperty p) &#123; if ( p.isAnnotationPresent( OneToOne.class ) &amp;&amp; !p.getAnnotation( OneToOne.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( OneToMany.class ) &amp;&amp; !p.getAnnotation( OneToMany.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToOne.class ) &amp;&amp; !p.getAnnotation( ManyToOne.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToMany.class ) &amp;&amp; !p.getAnnotation( ManyToMany.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( org.hibernate.annotations.Any.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToAny.class ) ) &#123; if ( !p.isCollection() &amp;&amp; !p.isArray() ) &#123; throw new AnnotationException( "@ManyToAny used on a non collection non array property: " + p.getName() ); &#125; return true; &#125; else if ( p.isAnnotationPresent( Type.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( Target.class ) ) &#123; return true; &#125; return false; &#125; private static boolean mustBeSkipped(XProperty property) &#123; //TODO make those hardcoded tests more portable (through the bytecode provider?) return property.isAnnotationPresent( Transient.class ) || "net.sf.cglib.transform.impl.InterceptFieldCallback".equals( property.getType().getName() ) || "org.hibernate.bytecode.internal.javassist.FieldHandler".equals( property.getType().getName() ); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaWeb应用防止xss攻击]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[1 . pom中增加依赖 123456&lt;!-- xss过滤组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt; 2 . 增加标签处理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xbz.utils;import org.apache.commons.lang3.StringUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.safety.Whitelist;import java.io.IOException;/*** ** xss非法标签过滤工具类* ** 过滤html中的xss字符* *** *@author* *xbz* **/public class JsoupUtil &#123;​ /***​ ** 使用自带的basicWithImages 白名单*​ ** 允许的便签有a,b,blockquote,br,cite,code,dd,dl,dt,em,i,li,ol,p,pre,q,small,span,*​ ** strike,strong,sub,sup,u,ul,img*​ ** 以及a标签的href,img标签的src,align,alt,height,width,title属性*​ **/​ private static final Whitelist whitelist = Whitelist.basicWithImages();​ /** 配置过滤化参数,不对代码进行格式化 \*/​ private static final Document.OutputSettings outputSettings = new Document.OutputSettings().prettyPrint(false);​ static &#123;​ // 富文本编辑时一些样式是使用style来进行实现的*​ // 比如红色字体 style="color:red;"*​ // 所以需要给所有标签添加style属性*​ whitelist.addAttributes(":all", "style");​ &#125;​ public static String clean(String *content*) &#123;​ if(StringUtils.isNotBlank(content))&#123;​ content = content.trim();​ &#125;​ return Jsoup.clean(content, "", whitelist, outputSettings);​ &#125;​ ​ public static void main(String[] *args*) throws IOException &#123;​ String text = " &lt;a href=\"http://www.baidu.com/a\" onclick=\"alert(1);\"&gt;sss&lt;/a&gt;&lt;script&gt;alert(0);&lt;/script&gt;sss ";​ System.out.println(clean(text));​ &#125;&#125; 3 . 重写请求参数处理函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.xbz.web.common.filter;import com.xbz.utils.JsoupUtil;import org.apache.commons.lang3.StringUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;/*** ** &lt;code&gt;&#123;@link XssHttpServletRequestWrapper&#125;&lt;/code&gt;* *** *@author* **/public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; ​ HttpServletRequest orgRequest = null; ​ private boolean isIncludeRichText = false;​ public XssHttpServletRequestWrapper(HttpServletRequest *request*, boolean *isIncludeRichText*) &#123; ​ super(request); ​ orgRequest = request;​ this.isIncludeRichText = isIncludeRichText;​ &#125; ​ /*** ​ ** 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt;* ​ ** 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt;* ​ ** getParameterNames,getParameterValues和getParameterMap也可能需要覆盖* ​ **/ ​ @Override ​ public String getParameter(String *name*) &#123;​ Boolean flag = ("content".equals(name) || name.endsWith("WithHtml"));​ if( flag &amp;&amp; !isIncludeRichText)&#123;​ return super.getParameter(name);​ &#125;​ name = JsoupUtil.clean(name);​ String value = super.getParameter(name); ​ if (StringUtils.isNotBlank(value)) &#123;​ value = JsoupUtil.clean(value);​ &#125;​ return value; ​ &#125; ​ ​ @Override​ public String[] getParameterValues(String *name*) &#123;​ String[] arr = super.getParameterValues(name);​ if(arr != null)&#123;​ for (int i=0;i&lt;arr.length;i++) &#123;​ arr[i] = JsoupUtil.clean(arr[i]);​ &#125;​ &#125;​ return arr;​ &#125;​ ​ /*** ​ ** 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt;* ​ ** 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt;* ​ ** getHeaderNames 也可能需要覆盖* ​ **/ ​ @Override ​ public String getHeader(String *name*) &#123; ​ name = JsoupUtil.clean(name);​ String value = super.getHeader(name); ​ if (StringUtils.isNotBlank(value)) &#123; ​ value = JsoupUtil.clean(value); ​ &#125; ​ return value; ​ &#125; ​ /*** ​ ** 获取最原始的request* ​ *** ​ *** *@return* ​ **/​ public HttpServletRequest getOrgRequest() &#123; ​ return orgRequest; ​ &#125; ​ /*** ​ ** 获取最原始的request的静态方法* ​ *** ​ *** *@return* ​ **/ ​ public static HttpServletRequest getOrgRequest(HttpServletRequest *req*) &#123; ​ if (req instanceof XssHttpServletRequestWrapper) &#123; ​ return ((XssHttpServletRequestWrapper) req).getOrgRequest(); ​ &#125; ​ return req; ​ &#125; &#125; 4 . 编写XSSFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.xbz.web.common.filter;import org.apache.commons.lang3.BooleanUtils;import org.apache.commons.lang3.StringUtils;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** ** 拦截防止xss注入* ** 通过Jsoup过滤请求参数内的特定字符* *** *@author* *yangwk* **/public class XssFilter implements Filter &#123; ​ private static final Logger logger = LogManager.getLogger();​ /***​ ** 是否过滤富文本内容*​ **/​ private static boolean IS_INCLUDE_RICH_TEXT = false;​ ​ public List&lt;String&gt; excludes = new ArrayList&lt;&gt;();​ @Override​ public void doFilter(ServletRequest *request*, ServletResponse *response*, FilterChain *filterChain*) throws IOException,ServletException &#123;​ if(logger.isDebugEnabled())&#123;​ logger.debug("xss filter is open");​ &#125;​ ​ HttpServletRequest req = (HttpServletRequest) request;​ HttpServletResponse resp = (HttpServletResponse) response;​ if(handleExcludeURL(req, resp))&#123;​ filterChain.doFilter(request, response);​ return;​ &#125;​ ​ XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request,IS_INCLUDE_RICH_TEXT);​ filterChain.doFilter(xssRequest, response);​ &#125;​ ​ private boolean handleExcludeURL(HttpServletRequest *request*, HttpServletResponse *response*) &#123;​ if (excludes == null || excludes.isEmpty()) &#123;​ return false;​ &#125;​ String url = request.getServletPath();​ for (String pattern : excludes) &#123;​ Pattern p = Pattern.compile("^" + pattern);​ Matcher m = p.matcher(url);​ if (m.find()) &#123;​ return true;​ &#125;​ &#125;​ return false;​ &#125;​ @Override​ public void init(FilterConfig *filterConfig*) throws ServletException &#123;​ if(logger.isDebugEnabled())&#123;​ logger.debug("xss filter init ====================");​ &#125;​ String isIncludeRichText = filterConfig.getInitParameter("isIncludeRichText");​ if(StringUtils.isNotBlank(isIncludeRichText))&#123;​ IS_INCLUDE_RICH_TEXT = BooleanUtils.toBoolean(isIncludeRichText);​ &#125;​ ​ String temp = filterConfig.getInitParameter("excludes");​ if (temp != null) &#123;​ String[] url = temp.split(",");​ for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123;​ excludes.add(url[i]);​ &#125;​ &#125;​ &#125;​ @Override​ public void destroy() &#123;&#125; &#125; 5 . 增加XSS配置 12345678910111213141516171819202122232425262728package com.xbz.web.common.config;import com.xbz.web.common.filter.XssFilter;import com.google.common.collect.Maps;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Map;@Configurationpublic class XssConfig&#123;​ /***​ ** xss过滤拦截器*​ **/​ @Bean​ public FilterRegistrationBean xssFilterRegistrationBean() &#123;​ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();​ filterRegistrationBean.setFilter(new XssFilter());​ filterRegistrationBean.setOrder(1);​ filterRegistrationBean.setEnabled(true);​ filterRegistrationBean.addUrlPatterns("/*");​ Map&lt;String, String&gt; initParameters = Maps.newHashMap();​ initParameters.put("excludes", "/favicon.ico,/img/*,/js/*,/css/*");​ initParameters.put("isIncludeRichText", "true");​ filterRegistrationBean.setInitParameters(initParameters);​ return filterRegistrationBean;​ &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[查看端口占用 1netstat -aon|findstr "8080" 查看具体的进程 1tasklist|findstr "4416" 终止某个进程 1taskkill /F /T /IM nginx.exe]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建数据库]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[表空间：tablespace为表空间名;datafile为存放.dbf文件的路径 1create tablespace struts2 datafile 'E:\oracle\dmp\struts2.dbf' size 500m 用户：用户名struts2 密码 1 默认表空间名struts2 1create user struts2 identified by 1 default tablespace struts2 quota unlimited on struts2; 给用户分配权限 1grant dba to struts2; 分配系统权限 123grant unlimited tablespace to struts2;grant create session to struts2]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改oracle字符集为AL32UTF8]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[123456789101112131415161718[oracle@VM_191_239_centos ~]$ sqlplus /nologSQL&gt; conn /as sysdbaSQL&gt; shutdown immediate;SQL&gt; startup mountSQL&gt; ALTER SYSTEM ENABLE RESTRICTED SESSION;SQL&gt; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;SQL&gt; ALTER SYSTEM SET AQ_TM_PROCESSES=0;SQL&gt; alter database open;SQL&gt; ALTER DATABASE CHARACTER SET AL32UTF8; ORA-12712: new character set must be a superset of old character set --提示我们的字符集：新字符集必须为旧字符集的超集，这时我们可以跳过超集的检查做更改：SQL&gt; ALTER DATABASE character set INTERNAL_USE AL32UTF8; --我们看到这个过程和之前ALTER DATABASE CHARACTER SET操作的内部过程是完全相同的，也就是说INTERNAL_USE提供的帮助就是使Oracle数据库绕过了子集与超集的校验.SQL&gt; select * from v$nls_parameters; SQL&gt; shutdown immediate;SQL&gt; startupSQL&gt; select * from v$nls_parameters;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决WEB应用接口调用时跨域以及session失效问题]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[场景复现springboot应用前后端分离,客户跨域调用开放接口验证验证码时,输入正确的验证码无法通过验证 解决方案方案一 :直接在 Controller 上使用@CrossOrigin 注解(版本要求Spring MVC4.2 + , 未验证) 方案二 :重写 Filter 的 doFilter 方法 1234567891011121314151617181920212223242526import org.springframework.stereotype.Component; import javax.servlet.\*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;public class CorsFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; HttpServletRequest request = (HttpServletRequest)req; response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin")); response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "x-requested-with"); response.setHeader("Access-Control-Allow-Credentials","true"); chain.doFilter(req, res); &#125; @Override public void destroy() &#123; &#125;&#125; ​ 前端调用请求时加上: xhrFields: {withCredentials: true},crossDomain: true 12345678910111213 $.ajax(&#123; type: 'POST', url: '/IGI/openPublicApplication/depts', xhrFields: &#123;withCredentials: true&#125;, crossDomain: true data:&#123; ...&#125;, dataType: 'json', success: function(data) &#123; ... &#125; &#125;);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>跨域</tag>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache开启反向代理-windows]]></title>
    <url>%2Fpost%2Fundefined.html</url>
    <content type="text"><![CDATA[修改httpd.conf配置文件1. 反注释以下模块12345678LoadModule negotiation_module modules/mod_negotiation.soLoadModule proxy_module modules/mod_proxy.soLoadModule proxy_ajp_module modules/mod_proxy_ajp.soLoadModule proxy_balancer_module modules/mod_proxy_balancer.soLoadModule proxy_connect_module modules/mod_proxy_connect.soLoadModule proxy_ftp_module modules/mod_proxy_ftp.soLoadModule proxy_http_module modules/mod_proxy_http.soLoadModule slotmem_shm_module modules/mod_slotmem_shm.so 2. 设置需要反向代理的url12ProxyPass /test http://192.168.200.124/testProxyPassReverse /test http://192.168.200.124/test]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>反向代理</tag>
        <tag>windows</tag>
      </tags>
  </entry>
</search>
