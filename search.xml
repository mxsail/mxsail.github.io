<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows10 四月更新启用文件名大小写敏感]]></title>
    <url>%2Fpost%2F3a15e7e.html</url>
    <content type="text"><![CDATA[basic1234# 开启大小写敏感fsutil.exe file SetCaseSensitiveInfo &lt;文件夹绝对路径&gt; enable# 关闭大小写敏感fsutil.exe file SetCaseSensitiveInfo &lt;文件夹绝对路径&gt; disable 注意事项: 只支持windows10 四月更新及以上版本; 在操作前你需要明确知道哪些文件夹你需要启用区分功能，因为开启该功能并不是全局而是针对特定文件夹; 文件夹所在分区的格式是NTFS; 必须以管理员身份执行以上命令; 慎重开启该功能!!! 开启大小写敏感是为了存储Linux子系统(WSL,Windows Subsystem for Linux)文件用。隨意开启可能导致各种未知错误。]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慎重使用InetAddress.getLocalHost().getHostAddress()]]></title>
    <url>%2Fpost%2Fb738736f.html</url>
    <content type="text"><![CDATA[问题: 如果在/etc/hosts配置错误,无法通过hostname找到对应的ip地址? 获取到的是真实的服务器ip地址?]]></content>
      <categories>
        <category>-java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 命名策略配置]]></title>
    <url>%2Fpost%2Ff0ad81e.html</url>
    <content type="text"><![CDATA[1 概述​ 对象模型到关系数据库的映射的一部分是将对象模型中的名称映射到相应的数据库名称。Hibernate5将此视为两阶段过程： 第一阶段是从域模型映射中确定正确的逻辑名称。逻辑名可以由用户显式指定（例如使用@Column或 @Table），也可以由Hibernate通过ImplicitNamingStrategy策略隐式确定 。 第二阶段是将此逻辑名称解析为PhysicalNamingStrategy策略定义的物理名称。 ​ 可以通过分别设置spring.jpa.hibernate.naming.physical-strategy和 spring.jpa.hibernate.naming.implicit-strategy配置来设置物理策略实现和隐式策略实现的完全限定类名。或者，如果ImplicitNamingStrategy或者PhysicalNamingStrategybean在应用程序上下文中可用，Hibernate将自动配置为使用它们。​ 默认情况下，Spring Boot配置物理命名策略 SpringPhysicalNamingStrategy。这个实现提供了与Hibernate 4相同的表结构：所有点都被下划线替换，而驼峰外壳也被下划线替换。默认情况下，所有表名都以小写形式生成，但如果您的架构需要，可以覆盖该策略。 历史命名策略: 历史上，Hibernate只定义了一个org.hibernate.cfg.NamingStrategy。这个单一的命名策略通常不够灵活,无法正确的应用给定的命名“规则”，因为API缺乏可供决定的信息,或者是因为在发展过程中没有定义好。由于这些限制,org.hibernate.cfg.NamingStrategy已经被弃用,然后删除。 每个命名策略背后的理念是最小化开发人员必须为映射域模型提供的重复信息量。 2 依赖12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.3.6.Final&lt;/version&gt;&lt;/dependency&gt; 3 隐式命名策略(ImplicitNamingStrategy)隐式命名策略(ImplicitNamingStrategy)的作用是当实体没有显式命名（例如使用@Column或 @Table）它映射到的数据库表，或者，当某个特定属性没有显式命名它映射到的数据库列时，确定逻辑名称。 Hibernate定义了多个ImplicitNamingStrategy实现。我们可以从四种内置策略中进行选择，或者我们可以创建自己的策略。 有多种方法可以指定要使用的ImplicitNamingStrategy。 应用程序可以使用 spring.jpa.hibernate.naming.implicit-strategy配置设置指定实现 四种内置策略: ImplicitNamingStrategyJpaCompliantImpl : 默认,符合JPA 2.0标准的命名策略 ImplicitNamingStrategyLegacyHbmImpl: 符合原始的Hibernate命名策略 ImplicitNamingStrategyLegacyJpaImpl: 符合为JPA 1.0开发的遗留命名策略 ImplicitNamingStrategyComponentPathImpl: 主要遵循ImplicitNamingStrategyJpaCompliantImpl规则，除了它使用完整的复合路径，而不仅仅是结束属性部分 引用实现org.hibernate.boot.model.naming.ImplicitNamingStrategy的类 实现org.hibernate.boot.model.naming.ImplicitNamingStrategy合同的类的FQN 应用程序和集成可以利用org.hibernate.boot.MetadataBuilder#applyImplicitNamingStrategy 指定要使用的ImplicitNamingStrategy。 4 物理命名策略(PhysicalNamingStrategy)许多组织围绕数据库对象（表，列，外键等）的命名定义规则。PhysicalNamingStrategy的想法是帮助实现这样的命名规则，而不必通过显式名称将它们硬编码到映射中。 举个例子,在没有明确指定时,隐式命名策略是将accountNumber属性映射到逻辑列名accountNumber,而物理命名策略的作用是将nickName映射到物理列名acct_num 虽然,在这种情况下映射到acct_num可以通过隐式命名策略来实现,但重点是分离关注点。无论属性是否明确指定列名，或者我们是否隐式确定，都将应用PhysicalNamingStrategy。只有在未给出显式名称时才会应用ImplicitNamingStrategy。所以它取决于需求和意图。 默认实现是简单地使用逻辑名称作为物理名称。但是，应用程序可以自定义PhysicalNamingStrategy的实现。 举个例子: 以下是一个名为Acme Corp的虚构公司的PhysicalNamingStrategy示例，其命名标准是： 喜欢用下划线分隔的单词而不是骆驼套管 用标准缩写替换某些单词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/* * Hibernate, Relational Persistence for Idiomatic Java * * License: GNU Lesser General Public License (LGPL), version 2.1 or later. * See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;. */package org.hibernate.userguide.naming;import java.util.LinkedList;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.TreeMap;import org.hibernate.boot.model.naming.Identifier;import org.hibernate.boot.model.naming.PhysicalNamingStrategy;import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;import org.apache.commons.lang3.StringUtils;/** * An example PhysicalNamingStrategy that implements database object naming standards * for our fictitious company Acme Corp. * &lt;p/&gt; * In general Acme Corp prefers underscore-delimited words rather than camel casing. * &lt;p/&gt; * Additionally standards call for the replacement of certain words with abbreviations. * * @author Steve Ebersole */public class AcmeCorpPhysicalNamingStrategy implements PhysicalNamingStrategy &#123; private static final Map&lt;String,String&gt; ABBREVIATIONS = buildAbbreviationMap(); @Override public Identifier toPhysicalCatalogName(Identifier name, JdbcEnvironment jdbcEnvironment) &#123; // Acme naming standards do not apply to catalog names return name; &#125; @Override public Identifier toPhysicalSchemaName(Identifier name, JdbcEnvironment jdbcEnvironment) &#123; // Acme naming standards do not apply to schema names return name; &#125; @Override public Identifier toPhysicalTableName(Identifier name, JdbcEnvironment jdbcEnvironment) &#123; final List&lt;String&gt; parts = splitAndReplace( name.getText() ); return jdbcEnvironment.getIdentifierHelper().toIdentifier( join( parts ), name.isQuoted() ); &#125; @Override public Identifier toPhysicalSequenceName(Identifier name, JdbcEnvironment jdbcEnvironment) &#123; final LinkedList&lt;String&gt; parts = splitAndReplace( name.getText() ); // Acme Corp says all sequences should end with _seq if ( !"seq".equalsIgnoreCase( parts.getLast() ) ) &#123; parts.add( "seq" ); &#125; return jdbcEnvironment.getIdentifierHelper().toIdentifier( join( parts ), name.isQuoted() ); &#125; @Override public Identifier toPhysicalColumnName(Identifier name, JdbcEnvironment jdbcEnvironment) &#123; final List&lt;String&gt; parts = splitAndReplace( name.getText() ); return jdbcEnvironment.getIdentifierHelper().toIdentifier( join( parts ), name.isQuoted() ); &#125; private static Map&lt;String, String&gt; buildAbbreviationMap() &#123; TreeMap&lt;String,String&gt; abbreviationMap = new TreeMap&lt;&gt; ( String.CASE_INSENSITIVE_ORDER ); abbreviationMap.put( "account", "acct" ); abbreviationMap.put( "number", "num" ); return abbreviationMap; &#125; private LinkedList&lt;String&gt; splitAndReplace(String name) &#123; LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;(); for ( String part : StringUtils.splitByCharacterTypeCamelCase( name ) ) &#123; if ( part == null || part.trim().isEmpty() ) &#123; // skip null and space continue; &#125; part = applyAbbreviationReplacement( part ); result.add( part.toLowerCase( Locale.ROOT ) ); &#125; return result; &#125; private String applyAbbreviationReplacement(String word) &#123; if ( ABBREVIATIONS.containsKey( word ) ) &#123; return ABBREVIATIONS.get( word ); &#125; return word; &#125; private String join(List&lt;String&gt; parts) &#123; boolean firstPass = true; String separator = ""; StringBuilder joined = new StringBuilder(); for ( String part : parts ) &#123; joined.append( separator ).append( part ); if ( firstPass ) &#123; firstPass = false; separator = "_"; &#125; &#125; return joined.toString(); &#125;&#125; 有多种方法可以指定要使用的PhysicalNamingStrategy。 首先，应用程序可以使用spring.jpa.hibernate.naming.physical-strategy配置设置指定实现，该配置设置接受： 引用实现org.hibernate.boot.model.naming.PhysicalNamingStrategy合同的类 实现org.hibernate.boot.model.naming.PhysicalNamingStrategy合同的类的FQN 其次，应用程序和集成可以利用org.hibernate.boot.MetadataBuilder#applyPhysicalNamingStrategy。 参考资料: &lt;https://www.baeldung.com/hibernate-naming-strategy https://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#naming]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hibernate自动生成的表字段顺序与实体类顺序不一致的问题]]></title>
    <url>%2Fpost%2F565abe7e.html</url>
    <content type="text"><![CDATA[重写hibernate的PropertyContainer,使创建的表的顺序与实体类顺序一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300package org.hibernate.cfg;import org.hibernate.AnnotationException;import org.hibernate.MappingException;import org.hibernate.annotations.ManyToAny;import org.hibernate.annotations.Target;import org.hibernate.annotations.Type;import org.hibernate.annotations.common.reflection.XClass;import org.hibernate.annotations.common.reflection.XProperty;import org.hibernate.boot.jaxb.Origin;import org.hibernate.boot.jaxb.SourceType;import org.hibernate.cfg.annotations.HCANNHelper;import org.hibernate.internal.CoreMessageLogger;import org.hibernate.internal.util.StringHelper;import org.jboss.logging.Logger;import javax.persistence.*;import java.util.*;/** * 重写hibernate的PropertyContainer,使创建的表的顺序与实体类顺序一致 * * */class PropertyContainer &#123; private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PropertyContainer.class.getName()); /** * The class for which this container is created. */ private final XClass xClass; private final XClass entityAtStake; /** * Holds the AccessType indicated for use at the class/container-level for cases where persistent attribute * did not specify. */ private final AccessType classLevelAccessType; private final LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap; PropertyContainer(XClass clazz, XClass entityAtStake, AccessType defaultClassLevelAccessType) &#123; this.xClass = clazz; this.entityAtStake = entityAtStake; if ( defaultClassLevelAccessType == AccessType.DEFAULT ) &#123; // this is effectively what the old code did when AccessType.DEFAULT was passed in // to getProperties(AccessType) from AnnotationBinder and InheritanceState defaultClassLevelAccessType = AccessType.PROPERTY; &#125; AccessType localClassLevelAccessType = determineLocalClassDefinedAccessStrategy(); assert localClassLevelAccessType != null; this.classLevelAccessType = localClassLevelAccessType != AccessType.DEFAULT ? localClassLevelAccessType : defaultClassLevelAccessType; assert classLevelAccessType == AccessType.FIELD || classLevelAccessType == AccessType.PROPERTY; this.persistentAttributeMap = new LinkedHashMap&lt;String, XProperty&gt;(); final List&lt;XProperty&gt; fields = xClass.getDeclaredProperties( AccessType.FIELD.getType() ); final List&lt;XProperty&gt; getters = xClass.getDeclaredProperties( AccessType.PROPERTY.getType() ); preFilter( fields, getters ); final Map&lt;String,XProperty&gt; persistentAttributesFromGetters = new HashMap&lt;String, XProperty&gt;(); collectPersistentAttributesUsingLocalAccessType( persistentAttributeMap, persistentAttributesFromGetters, fields, getters ); collectPersistentAttributesUsingClassLevelAccessType( persistentAttributeMap, persistentAttributesFromGetters, fields, getters ); &#125; private void preFilter(List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; Iterator&lt;XProperty&gt; propertyIterator = fields.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty property = propertyIterator.next(); if ( mustBeSkipped( property ) ) &#123; propertyIterator.remove(); &#125; &#125; propertyIterator = getters.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty property = propertyIterator.next(); if ( mustBeSkipped( property ) ) &#123; propertyIterator.remove(); &#125; &#125; &#125; private void collectPersistentAttributesUsingLocalAccessType( LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap, Map&lt;String,XProperty&gt; persistentAttributesFromGetters, List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; // Check fields... Iterator&lt;XProperty&gt; propertyIterator = fields.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty xProperty = propertyIterator.next(); final Access localAccessAnnotation = xProperty.getAnnotation( Access.class ); if ( localAccessAnnotation == null || localAccessAnnotation.value() != javax.persistence.AccessType.FIELD ) &#123; continue; &#125; propertyIterator.remove(); persistentAttributeMap.put( xProperty.getName(), xProperty ); &#125; // Check getters... propertyIterator = getters.iterator(); while ( propertyIterator.hasNext() ) &#123; final XProperty xProperty = propertyIterator.next(); final Access localAccessAnnotation = xProperty.getAnnotation( Access.class ); if ( localAccessAnnotation == null || localAccessAnnotation.value() != javax.persistence.AccessType.PROPERTY ) &#123; continue; &#125; propertyIterator.remove(); final String name = xProperty.getName(); // HHH-10242 detect registration of the same property getter twice - eg boolean isId() + UUID getId() final XProperty previous = persistentAttributesFromGetters.get( name ); if ( previous != null ) &#123; throw new org.hibernate.boot.MappingException( LOG.ambiguousPropertyMethods( xClass.getName(), HCANNHelper.annotatedElementSignature( previous ), HCANNHelper.annotatedElementSignature( xProperty ) ), new Origin( SourceType.ANNOTATION, xClass.getName() ) ); &#125; persistentAttributeMap.put( name, xProperty ); persistentAttributesFromGetters.put( name, xProperty ); &#125; &#125; private void collectPersistentAttributesUsingClassLevelAccessType( LinkedHashMap&lt;String, XProperty&gt; persistentAttributeMap, Map&lt;String,XProperty&gt; persistentAttributesFromGetters, List&lt;XProperty&gt; fields, List&lt;XProperty&gt; getters) &#123; if ( classLevelAccessType == AccessType.FIELD ) &#123; for ( XProperty field : fields ) &#123; if ( persistentAttributeMap.containsKey( field.getName() ) ) &#123; continue; &#125; persistentAttributeMap.put( field.getName(), field ); &#125; &#125; else &#123; for ( XProperty getter : getters ) &#123; final String name = getter.getName(); // HHH-10242 detect registration of the same property getter twice - eg boolean isId() + UUID getId() final XProperty previous = persistentAttributesFromGetters.get( name ); if ( previous != null ) &#123; throw new org.hibernate.boot.MappingException( LOG.ambiguousPropertyMethods( xClass.getName(), HCANNHelper.annotatedElementSignature( previous ), HCANNHelper.annotatedElementSignature( getter ) ), new Origin( SourceType.ANNOTATION, xClass.getName() ) ); &#125; if ( persistentAttributeMap.containsKey( name ) ) &#123; continue; &#125; persistentAttributeMap.put( getter.getName(), getter ); persistentAttributesFromGetters.put( name, getter ); &#125; &#125; &#125; public XClass getEntityAtStake() &#123; return entityAtStake; &#125; public XClass getDeclaringClass() &#123; return xClass; &#125; public AccessType getClassLevelAccessType() &#123; return classLevelAccessType; &#125; public Collection&lt;XProperty&gt; getProperties() &#123; assertTypesAreResolvable(); return Collections.unmodifiableCollection( persistentAttributeMap.values() ); &#125; private void assertTypesAreResolvable() &#123; for ( XProperty xProperty : persistentAttributeMap.values() ) &#123; if ( !xProperty.isTypeResolved() &amp;&amp; !discoverTypeWithoutReflection( xProperty ) ) &#123; String msg = "Property " + StringHelper.qualify( xClass.getName(), xProperty.getName() ) + " has an unbound type and no explicit target entity. Resolve this Generic usage issue" + " or set an explicit target attribute (eg @OneToMany(target=) or use an explicit @Type"; throw new AnnotationException( msg ); &#125; &#125; &#125; private AccessType determineLocalClassDefinedAccessStrategy() &#123; AccessType classDefinedAccessType; AccessType hibernateDefinedAccessType = AccessType.DEFAULT; AccessType jpaDefinedAccessType = AccessType.DEFAULT; org.hibernate.annotations.AccessType accessType = xClass.getAnnotation( org.hibernate.annotations.AccessType.class ); if ( accessType != null ) &#123; hibernateDefinedAccessType = AccessType.getAccessStrategy( accessType.value() ); &#125; Access access = xClass.getAnnotation( Access.class ); if ( access != null ) &#123; jpaDefinedAccessType = AccessType.getAccessStrategy( access.value() ); &#125; if ( hibernateDefinedAccessType != AccessType.DEFAULT &amp;&amp; jpaDefinedAccessType != AccessType.DEFAULT &amp;&amp; hibernateDefinedAccessType != jpaDefinedAccessType ) &#123; throw new MappingException( "@AccessType and @Access specified with contradicting values. Use of @Access only is recommended. " ); &#125; if ( hibernateDefinedAccessType != AccessType.DEFAULT ) &#123; classDefinedAccessType = hibernateDefinedAccessType; &#125; else &#123; classDefinedAccessType = jpaDefinedAccessType; &#125; return classDefinedAccessType; &#125; private static boolean discoverTypeWithoutReflection(XProperty p) &#123; if ( p.isAnnotationPresent( OneToOne.class ) &amp;&amp; !p.getAnnotation( OneToOne.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( OneToMany.class ) &amp;&amp; !p.getAnnotation( OneToMany.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToOne.class ) &amp;&amp; !p.getAnnotation( ManyToOne.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToMany.class ) &amp;&amp; !p.getAnnotation( ManyToMany.class ) .targetEntity() .equals( void.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( org.hibernate.annotations.Any.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( ManyToAny.class ) ) &#123; if ( !p.isCollection() &amp;&amp; !p.isArray() ) &#123; throw new AnnotationException( "@ManyToAny used on a non collection non array property: " + p.getName() ); &#125; return true; &#125; else if ( p.isAnnotationPresent( Type.class ) ) &#123; return true; &#125; else if ( p.isAnnotationPresent( Target.class ) ) &#123; return true; &#125; return false; &#125; private static boolean mustBeSkipped(XProperty property) &#123; //TODO make those hardcoded tests more portable (through the bytecode provider?) return property.isAnnotationPresent( Transient.class ) || "net.sf.cglib.transform.impl.InterceptFieldCallback".equals( property.getType().getName() ) || "org.hibernate.bytecode.internal.javassist.FieldHandler".equals( property.getType().getName() ); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaWeb应用防止xss攻击]]></title>
    <url>%2Fpost%2F3f255a8b.html</url>
    <content type="text"><![CDATA[1 . pom中增加依赖 123456&lt;!-- xss过滤组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt; 2 . 增加标签处理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xbz.utils;import org.apache.commons.lang3.StringUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.safety.Whitelist;import java.io.IOException;/*** ** xss非法标签过滤工具类* ** 过滤html中的xss字符* *** *@author* *xbz* **/public class JsoupUtil &#123;​ /***​ ** 使用自带的basicWithImages 白名单*​ ** 允许的便签有a,b,blockquote,br,cite,code,dd,dl,dt,em,i,li,ol,p,pre,q,small,span,*​ ** strike,strong,sub,sup,u,ul,img*​ ** 以及a标签的href,img标签的src,align,alt,height,width,title属性*​ **/​ private static final Whitelist whitelist = Whitelist.basicWithImages();​ /** 配置过滤化参数,不对代码进行格式化 \*/​ private static final Document.OutputSettings outputSettings = new Document.OutputSettings().prettyPrint(false);​ static &#123;​ // 富文本编辑时一些样式是使用style来进行实现的*​ // 比如红色字体 style="color:red;"*​ // 所以需要给所有标签添加style属性*​ whitelist.addAttributes(":all", "style");​ &#125;​ public static String clean(String *content*) &#123;​ if(StringUtils.isNotBlank(content))&#123;​ content = content.trim();​ &#125;​ return Jsoup.clean(content, "", whitelist, outputSettings);​ &#125;​ ​ public static void main(String[] *args*) throws IOException &#123;​ String text = " &lt;a href=\"http://www.baidu.com/a\" onclick=\"alert(1);\"&gt;sss&lt;/a&gt;&lt;script&gt;alert(0);&lt;/script&gt;sss ";​ System.out.println(clean(text));​ &#125;&#125; 3 . 重写请求参数处理函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.xbz.web.common.filter;import com.xbz.utils.JsoupUtil;import org.apache.commons.lang3.StringUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;/*** ** &lt;code&gt;&#123;@link XssHttpServletRequestWrapper&#125;&lt;/code&gt;* *** *@author* **/public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; ​ HttpServletRequest orgRequest = null; ​ private boolean isIncludeRichText = false;​ public XssHttpServletRequestWrapper(HttpServletRequest *request*, boolean *isIncludeRichText*) &#123; ​ super(request); ​ orgRequest = request;​ this.isIncludeRichText = isIncludeRichText;​ &#125; ​ /*** ​ ** 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt;* ​ ** 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt;* ​ ** getParameterNames,getParameterValues和getParameterMap也可能需要覆盖* ​ **/ ​ @Override ​ public String getParameter(String *name*) &#123;​ Boolean flag = ("content".equals(name) || name.endsWith("WithHtml"));​ if( flag &amp;&amp; !isIncludeRichText)&#123;​ return super.getParameter(name);​ &#125;​ name = JsoupUtil.clean(name);​ String value = super.getParameter(name); ​ if (StringUtils.isNotBlank(value)) &#123;​ value = JsoupUtil.clean(value);​ &#125;​ return value; ​ &#125; ​ ​ @Override​ public String[] getParameterValues(String *name*) &#123;​ String[] arr = super.getParameterValues(name);​ if(arr != null)&#123;​ for (int i=0;i&lt;arr.length;i++) &#123;​ arr[i] = JsoupUtil.clean(arr[i]);​ &#125;​ &#125;​ return arr;​ &#125;​ ​ /*** ​ ** 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt;* ​ ** 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt;* ​ ** getHeaderNames 也可能需要覆盖* ​ **/ ​ @Override ​ public String getHeader(String *name*) &#123; ​ name = JsoupUtil.clean(name);​ String value = super.getHeader(name); ​ if (StringUtils.isNotBlank(value)) &#123; ​ value = JsoupUtil.clean(value); ​ &#125; ​ return value; ​ &#125; ​ /*** ​ ** 获取最原始的request* ​ *** ​ *** *@return* ​ **/​ public HttpServletRequest getOrgRequest() &#123; ​ return orgRequest; ​ &#125; ​ /*** ​ ** 获取最原始的request的静态方法* ​ *** ​ *** *@return* ​ **/ ​ public static HttpServletRequest getOrgRequest(HttpServletRequest *req*) &#123; ​ if (req instanceof XssHttpServletRequestWrapper) &#123; ​ return ((XssHttpServletRequestWrapper) req).getOrgRequest(); ​ &#125; ​ return req; ​ &#125; &#125; 4 . 编写XSSFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.xbz.web.common.filter;import org.apache.commons.lang3.BooleanUtils;import org.apache.commons.lang3.StringUtils;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** ** 拦截防止xss注入* ** 通过Jsoup过滤请求参数内的特定字符* *** *@author* *yangwk* **/public class XssFilter implements Filter &#123; ​ private static final Logger logger = LogManager.getLogger();​ /***​ ** 是否过滤富文本内容*​ **/​ private static boolean IS_INCLUDE_RICH_TEXT = false;​ ​ public List&lt;String&gt; excludes = new ArrayList&lt;&gt;();​ @Override​ public void doFilter(ServletRequest *request*, ServletResponse *response*, FilterChain *filterChain*) throws IOException,ServletException &#123;​ if(logger.isDebugEnabled())&#123;​ logger.debug("xss filter is open");​ &#125;​ ​ HttpServletRequest req = (HttpServletRequest) request;​ HttpServletResponse resp = (HttpServletResponse) response;​ if(handleExcludeURL(req, resp))&#123;​ filterChain.doFilter(request, response);​ return;​ &#125;​ ​ XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request,IS_INCLUDE_RICH_TEXT);​ filterChain.doFilter(xssRequest, response);​ &#125;​ ​ private boolean handleExcludeURL(HttpServletRequest *request*, HttpServletResponse *response*) &#123;​ if (excludes == null || excludes.isEmpty()) &#123;​ return false;​ &#125;​ String url = request.getServletPath();​ for (String pattern : excludes) &#123;​ Pattern p = Pattern.compile("^" + pattern);​ Matcher m = p.matcher(url);​ if (m.find()) &#123;​ return true;​ &#125;​ &#125;​ return false;​ &#125;​ @Override​ public void init(FilterConfig *filterConfig*) throws ServletException &#123;​ if(logger.isDebugEnabled())&#123;​ logger.debug("xss filter init ====================");​ &#125;​ String isIncludeRichText = filterConfig.getInitParameter("isIncludeRichText");​ if(StringUtils.isNotBlank(isIncludeRichText))&#123;​ IS_INCLUDE_RICH_TEXT = BooleanUtils.toBoolean(isIncludeRichText);​ &#125;​ ​ String temp = filterConfig.getInitParameter("excludes");​ if (temp != null) &#123;​ String[] url = temp.split(",");​ for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123;​ excludes.add(url[i]);​ &#125;​ &#125;​ &#125;​ @Override​ public void destroy() &#123;&#125; &#125; 5 . 增加XSS配置 12345678910111213141516171819202122232425262728package com.xbz.web.common.config;import com.xbz.web.common.filter.XssFilter;import com.google.common.collect.Maps;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Map;@Configurationpublic class XssConfig&#123;​ /***​ ** xss过滤拦截器*​ **/​ @Bean​ public FilterRegistrationBean xssFilterRegistrationBean() &#123;​ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();​ filterRegistrationBean.setFilter(new XssFilter());​ filterRegistrationBean.setOrder(1);​ filterRegistrationBean.setEnabled(true);​ filterRegistrationBean.addUrlPatterns("/*");​ Map&lt;String, String&gt; initParameters = Maps.newHashMap();​ initParameters.put("excludes", "/favicon.ico,/img/*,/js/*,/css/*");​ initParameters.put("isIncludeRichText", "true");​ filterRegistrationBean.setInitParameters(initParameters);​ return filterRegistrationBean;​ &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>xss</tag>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令]]></title>
    <url>%2Fpost%2Fa2bb437d.html</url>
    <content type="text"><![CDATA[查看端口占用 1netstat -aon|findstr "8080" 查看具体的进程 1tasklist|findstr "4416" 根据可执行文件名终止某个进程 1taskkill /F /T /IM &lt;可执行文件名&gt; 开启或者关闭某个服务 1234# 开启net start &lt;服务名&gt;# 关闭net stop &lt;服务名&gt;]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle创建数据库]]></title>
    <url>%2Fpost%2F53216387.html</url>
    <content type="text"><![CDATA[表空间：tablespace为表空间名;datafile为存放.dbf文件的路径 1create tablespace struts2 datafile 'E:\oracle\dmp\struts2.dbf' size 500m 用户：用户名struts2 密码 1 默认表空间名struts2 1create user struts2 identified by 1 default tablespace struts2 quota unlimited on struts2; 给用户分配权限 1grant dba to struts2; 分配系统权限 123grant unlimited tablespace to struts2;grant create session to struts2]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改oracle字符集为AL32UTF8]]></title>
    <url>%2Fpost%2Fe3021608.html</url>
    <content type="text"><![CDATA[123456789101112131415161718[oracle@VM_191_239_centos ~]$ sqlplus /nologSQL&gt; conn /as sysdbaSQL&gt; shutdown immediate;SQL&gt; startup mountSQL&gt; ALTER SYSTEM ENABLE RESTRICTED SESSION;SQL&gt; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;SQL&gt; ALTER SYSTEM SET AQ_TM_PROCESSES=0;SQL&gt; alter database open;SQL&gt; ALTER DATABASE CHARACTER SET AL32UTF8; ORA-12712: new character set must be a superset of old character set --提示我们的字符集：新字符集必须为旧字符集的超集，这时我们可以跳过超集的检查做更改：SQL&gt; ALTER DATABASE character set INTERNAL_USE AL32UTF8; --我们看到这个过程和之前ALTER DATABASE CHARACTER SET操作的内部过程是完全相同的，也就是说INTERNAL_USE提供的帮助就是使Oracle数据库绕过了子集与超集的校验.SQL&gt; select * from v$nls_parameters; SQL&gt; shutdown immediate;SQL&gt; startupSQL&gt; select * from v$nls_parameters;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决WEB应用接口调用时跨域以及session失效问题]]></title>
    <url>%2Fpost%2F61139f8a.html</url>
    <content type="text"><![CDATA[场景复现springboot应用前后端分离,客户跨域调用开放接口验证验证码时,输入正确的验证码无法通过验证 解决方案方案一 :直接在 Controller 上使用@CrossOrigin 注解(版本要求Spring MVC4.2 + , 未验证) 方案二 :重写 Filter 的 doFilter 方法 1234567891011121314151617181920212223242526import org.springframework.stereotype.Component; import javax.servlet.\*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;public class CorsFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; HttpServletRequest request = (HttpServletRequest)req; response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin")); response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "x-requested-with"); response.setHeader("Access-Control-Allow-Credentials","true"); chain.doFilter(req, res); &#125; @Override public void destroy() &#123; &#125;&#125; ​ 前端调用请求时加上: xhrFields: {withCredentials: true},crossDomain: true 12345678910111213 $.ajax(&#123; type: 'POST', url: '/IGI/openPublicApplication/depts', xhrFields: &#123;withCredentials: true&#125;, crossDomain: true data:&#123; ...&#125;, dataType: 'json', success: function(data) &#123; ... &#125; &#125;);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>api</tag>
        <tag>跨域</tag>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache开启反向代理-windows]]></title>
    <url>%2Fpost%2F2fb868b6.html</url>
    <content type="text"><![CDATA[修改httpd.conf配置文件1. 反注释以下模块12345678LoadModule negotiation_module modules/mod_negotiation.soLoadModule proxy_module modules/mod_proxy.soLoadModule proxy_ajp_module modules/mod_proxy_ajp.soLoadModule proxy_balancer_module modules/mod_proxy_balancer.soLoadModule proxy_connect_module modules/mod_proxy_connect.soLoadModule proxy_ftp_module modules/mod_proxy_ftp.soLoadModule proxy_http_module modules/mod_proxy_http.soLoadModule slotmem_shm_module modules/mod_slotmem_shm.so 2. 设置需要反向代理的url12ProxyPass /test http://192.168.200.124/testProxyPassReverse /test http://192.168.200.124/test]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>反向代理</tag>
        <tag>windows</tag>
      </tags>
  </entry>
</search>
